# Api Documentation
This documentation is autogenerated and may be incomplete

## `cyan.colorstring`
===

Some wrappers/conveniences around working with ansi escape codes For example getting the length of a string that contains escape codes shouldnt include them

### `ColorString:surround(col: {number})`
surrounds a string with a color

### `ColorString:tostring(): string`
Converts a `Colorstring` to a regular string with the correct ANSI escapes

### `colorstring.highlight(hl: {number}, str: string): ColorString`
Create a `Colorstring` by surrounding a string with the given ANSI color and an ANSI reset

### `colorstring.new(...: string | {number}): ColorString`
The `Colorstring` constructor

### `colorstring.rgb_bg(r: number, g: number, b: number): {number, number, number, number, number}`
The ansi escape for an arbitrary RGB background color

### `colorstring.rgb_fg(r: number, g: number, b: number): {number, number, number, number, number}`
The ansi escape for an arbitrary RGB foreground color

### record `ColorString`
The main object that this library consumes and produces. It basically implements the 'string' interface and can be used wherever a string is.

Colors are described as arrays of numbers that directly correspond to ANSI escape sequences

## `cyan.config`
===

Config loading API

### `config.is_config(c: any): Config, {string}, {string}`
Check if `c` conforms to the `Config` type and return any errors and warnings generated from checking

### `config.load(): Config, {string}, {string}`
Try to load `tlconfig.lua` in the current directory

### `config.merge_with_args(cfg: Config, args: command.Command.Args)`
Merge the relevant entries of the provided command arguments into the provided config table

### record `Config`
The config data

## `cyan.fs.path`
===

See if the given path matches any of the given patterns

### record `Path`
The main path object. Basically just an array of strings with some methods and metamethods to interact with other paths

## `cyan.fs`
===

Search for a file in the parent directories of the given path

### `fs.current_dir(): Path`
Get the current directory as an `fs.Path`

### `fs.dir(dir: string | Path, include_dotfiles: boolean): function(): Path`
Iterate over the given directory, returning `fs.Path` objects

By default, will not include paths that start with '.'

### `fs.scan_dir(dir: string | Path, include: {string}, exclude: {string}): function(): Path`
Recursively iterate over the files in a directory, following the provided `include` and `exclude` patterns

## `cyan.tlcommon`
===

Common things needed by most commands in addition to wrappers around the tl api, since it isn't super stable

### `common.init_env_from_cfg(cfg: config.Config): tl.Env, string`
Initialize a strict Teal environment, using the relevant entries of the config to modify that environment

may return `nil` and an error message if something could not be applied to the environment

### `common.init_teal_env(gen_compat: boolean | tl.CompatMode, gen_target: tl.TargetMode, preload: {string}): tl.Env, string`
Initialize a strict Teal environment

### `common.load_cfg_env_report_errs(require_config: boolean, args: command.Command.Args): boolean, config.Config, tl.Env`
Load the config file and initialize a Teal environment using it

### `common.load_config_report_errs(path: string, args: command.Command.Args): config.Config`
Load a config through `cyan.load_with_args` and report the errors, returning nil if there were any errors

### `common.make_error_header(file: string, num_errors: number, category: string): string`
Creates a nicely colored header to log errors

For example `make_error_header("foo.tl", 10, "foo error")` would produce something like `10 foo errors in foo.tl` with `10` and `foo.tl` highlighted

### `common.parse_result_to_tl_result(pr: ParseResult): tl.Result`
Creates a `tl.Result` from a `ParseResult`

### `common.prepend_to_lua_path(path_str: string)`
Prepend the given string to package.path and package.cpath.

Correctly adds ?.lua and ?/init.lua to the path

### `common.report_errors(logfn: function(...: any), errs: {tl.Error}, file: string, category: string)`
Logs an array of errors with nice colors and a header generated by `make_error_header`

### `common.report_result(file: string, r: tl.Result): boolean`
Logs all the syntax errors, warnings, type errors, etc. from a `tl.Result` with proper colors

Returns if there were any warnings or unknowns. May return `true` even if some warnings were reported

### `common.search_module(name: string, search_dtl: boolean): fs.Path`
A wrapper around `tl.search_module` but, returns an `fs.Path` and will cache results

### `common.type_check_ast(ast: Node, opts: tl.TypeCheckOptions)`
Just type checks an ast

### record `ParseResult`
The result from parsing source code including the tokens, ast, calls to require, and errors

