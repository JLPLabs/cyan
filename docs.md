# Api Documentation
This documentation is autogenerated and may be incomplete

## `cyan.colorstring`
---

Some wrappers/conveniences around working with ansi escape codes For example getting the length of a string that contains escape codes shouldnt include them

#### `ColorString:surround(col: {number})`
surrounds a string with a color

#### `ColorString:tostring(): string`
Converts a `Colorstring` to a regular string with the correct ANSI escapes

#### `colorstring.highlight(hl: {number}, str: string): ColorString`
Create a `Colorstring` by surrounding a string with the given ANSI color and an ANSI reset

#### `colorstring.new(...: string | {number}): ColorString`
The `Colorstring` constructor

#### `colorstring.rgb_bg(r: number, g: number, b: number): {number, number, number, number, number}`
The ansi escape for an arbitrary RGB background color

#### `colorstring.rgb_fg(r: number, g: number, b: number): {number, number, number, number, number}`
The ansi escape for an arbitrary RGB foreground color

#### `record ColorString`
```
local record ColorString
   content: {string | {number}}
   len: function(ColorString): number
   tostring: function(ColorString): string

   metamethod __len: function(ColorString): number
   metamethod __concat: function(ColorString | string, ColorString | string): ColorString
   -- metamethod __tostring: function(ColorString): string
end
```
The main object that this library consumes and produces. It basically implements the 'string' interface and can be used wherever a string is.

Colors are described as arrays of numbers that directly correspond to ANSI escape sequences

## `cyan.config`
---

Config loading API

#### `config.is_config(c: any): Config, {string}, {string}`
Check if `c` conforms to the `Config` type and return any errors and warnings generated from checking

#### `config.load(): Config, {string}, {string}`
Try to load `tlconfig.lua` in the current directory

#### `config.merge_with_args(cfg: Config, args: command.Command.Args)`
Merge the relevant entries of the provided command arguments into the provided config table

#### `record Config`
```
local record Config
   build_dir: string
   source_dir: string
   files: {string}
   include: {string}
   exclude: {string}
   preload_modules: {string}
   include_dir: {string}
   module_name: string

   gen_compat: tl.CompatMode
   gen_target: tl.TargetMode
   disable_warnings: {tl.WarningKind}
   warning_error: {tl.WarningKind}

   -- externals field to allow for external tools to take entries in the config
   -- without our type checking complaining
   externals: {any:any}
end
```
The config data

## `cyan.fs.path`
---

Object oriented path management

#### `Path:ancestors(): function(): Path`
Iterate over the leading folders in a path

ex: `path.new("foo/bar/baz/bat"):ancestors()` will construct `Path` objects from "foo", "foo/bar", "foo/bar/baz"

#### `Path:append(other: string | Path)`
Mutate the given `Path` by appending another path to it

#### `Path:copy(): Path`
Create a copy of the given path

#### `Path:exists(): boolean`
Check if the path exists

#### `Path:is_absolute(): boolean`
Returns whether the path is absolute

On windows, checks for paths like "C:\...", elsewhere looks for "/..."

#### `Path:is_directory(): boolean`
Get whether the "mode" attribute of the given path is set to "directory"

#### `Path:is_file(): boolean`
Get whether the "mode" attribute of the given path is set to "file"

#### `Path:match(patt: string): boolean`
See if the given path matches the pattern

Path separators in patterns are always represented with '/'.

`*` characters represent any number of non-path-separator characters

`**/` represent any number of directories

#### `Path:match_any(patts: {string}): number, string`
See if the given path matches any of the given patterns

#### `Path:mk_parent_dirs(): boolean, string`
Attempt to create the leading directories of a given path

#### `Path:mkdir(): boolean, string`
Attempt to create a directory at the given path, creating the parent directories if needed. Can be seen as an equivalent to `mkdir -p`

#### `Path:mod_time(): number`
Get the "modification" attribute of a file

#### `Path:prepend(other: string | Path)`
Mutate the given `Path` by prepending another path to it

#### `Path:relative_to(other: Path): string`
Expresses a path in terms of another path. If any relative paths are given, they are treated as though they are in the current directory

Returns an actual path since path objects cannot contain '..'

for example: `path.new("/foo/bar/baz"):relative_to(path.new("/foo/bat")) == "../bar/baz"`

#### `Path:remove_leading(p: string | Path)`
Mutate the given path by removing the leading parts from the given path

Will error if you attempt to mix absolute and non-absolute paths

#### `Path:to_real_path(): string`
Convert a `Path` to a string describing a real path

#### `Path:tostring(): string`
Convert a path to a string. Always uses '/' as a path separator. Intended for displaying purposes. For an actual path in the filesystem, use `Path:to_real_path()`

#### `path.new(s: string, use_os_sep: boolean): Path`
The `Path` constructor

By default uses '/' as a path separator

#### `record Path`
```
local record Path
   {string}

   metamethod __concat: function(Path | string, Path | string): Path
   metamethod __eq: function(Path | string, Path | string): boolean
   -- metamethod __tostring: function(Path): string
end
```
The main path object. Basically just an array of strings with some methods and metamethods to interact with other paths

## `cyan.fs`
---

Search for a file in the parent directories of the given path

#### `fs.current_dir(): Path`
Get the current directory as an `fs.Path`

#### `fs.dir(dir: string | Path, include_dotfiles: boolean): function(): Path`
Iterate over the given directory, returning `fs.Path` objects

By default, will not include paths that start with '.'

#### `fs.scan_dir(dir: string | Path, include: {string}, exclude: {string}): function(): Path`
Recursively iterate over the files in a directory, following the provided `include` and `exclude` patterns

## `cyan.graph`
---

#### `Dag:insert_file(fstr: string | fs.Path)`
Inserts a file and its dependencies into a graph

## `cyan.tlcommon`
---

Common things needed by most commands in addition to wrappers around the tl api, since it isn't super stable

#### `common.init_env_from_cfg(cfg: config.Config): tl.Env, string`
Initialize a strict Teal environment, using the relevant entries of the config to modify that environment

may return `nil` and an error message if something could not be applied to the environment

#### `common.init_teal_env(gen_compat: boolean | tl.CompatMode, gen_target: tl.TargetMode, preload: {string}): tl.Env, string`
Initialize a strict Teal environment

#### `common.load_cfg_env_report_errs(require_config: boolean, args: command.Command.Args): boolean, config.Config, tl.Env`
Load the config file and initialize a Teal environment using it

#### `common.load_config_report_errs(path: string, args: command.Command.Args): config.Config`
Load a config through `cyan.load_with_args` and report the errors, returning nil if there were any errors

#### `common.make_error_header(file: string, num_errors: number, category: string): string`
Creates a nicely colored header to log errors

For example `make_error_header("foo.tl", 10, "foo error")` would produce something like `10 foo errors in foo.tl` with `10` and `foo.tl` highlighted

#### `common.parse_result_to_tl_result(pr: ParseResult): tl.Result`
Creates a `tl.Result` from a `ParseResult`

#### `common.prepend_to_lua_path(path_str: string)`
Prepend the given string to package.path and package.cpath.

Correctly adds ?.lua and ?/init.lua to the path

#### `common.report_errors(logfn: function(...: any), errs: {tl.Error}, file: string, category: string)`
Logs an array of errors with nice colors and a header generated by `make_error_header`

#### `common.report_result(file: string, r: tl.Result, c: config.Config): boolean`
Logs all the syntax errors, warnings, type errors, etc. from a `tl.Result` with proper colors

Returns if there were any warnings or unknowns. May return `true` even if some warnings were reported

#### `common.search_module(name: string, search_dtl: boolean): fs.Path`
A wrapper around `tl.search_module` but, returns an `fs.Path` and will cache results

#### `common.type_check_ast(ast: Node, opts: tl.TypeCheckOptions)`
Just type checks an ast

#### `record ParseResult`
```
local record ParseResult
   tks: {Token}
   ast: Node
   reqs: {string}
   errs: {tl.Error}
end
```
The result from parsing source code including the tokens, ast, calls to require, and errors

